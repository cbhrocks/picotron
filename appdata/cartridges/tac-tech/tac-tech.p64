picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCIscmV2aXNpb249MzA1NF1dbHo0ACoCAABvMwAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSw_AC-x8DEA
HO-wAz8UMD4gDj8VDhAOPQQABnAgPjA_8AI_KgAGFQAPKQAGExOFAB8xhQAUU-8UARQOAgASHggA
NQ8VBAwAABYAIg0ECQAJFQAPCgArA1MALwQNIAABI-4BxAAfM8QAFB7wegEPMQCeP-8V8LoBHX8W
EPUA-xXANwAenxLVHgXPFR4FzQMADg9bAB_ftT4FnxUFPgWdBAAaHx5pAEo_tf4SYAAP7wEUDzEA
d-8bIhXgFeAVDw-ADjUecC4-ExVgHgA9FQ5AHh8bPRweMDw9LA4wrHBvFPAkiwAeDzEA-0TwBEIV
AA8VPxYPFQAVMBUODxY1DQ4JAJAdFR0OFTAFnQUEAG9QLhAu8ESLAB4PMQD------99hQGWAZXB1
AgD-FDUANXAlADVQNRAlYDUgFUA1QCUgNWAVEDVwhXA1ACVwJfARjgAd-w8lNUAKYBVQCQrVDxkJ
JRAFEDUQCQoFMAVwCkAV8GpOAB3-NQIJIAlgCQA-FgkuIAkA-iP-FBIvD08TDxQVPS8PDk8THRUt
Hw8eTxMtJQ0fD08bHxM9Hw8NDJ8bDSwNmzwFm0wNmxw9gQEeDzEA------------------------
-------------------------7JQbT04fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA3IDAzOjQ2OjQ4Iixtb2RpZmllZD0iMjAyNS0w
MS0wNyAwMzo0Njo0OCIscmV2aXNpb249MF1dbHo0AOkBAADRIAAA8Ah7e2JtcD11c2VyZGF0YSgi
aTE2IiwzMgMALyIwAQD-----Ny8zMAEAZxMyBAAPAQD-1g-sAQkfMtgCWB4zLAAPlAA_LzMw7AAP
LzMwAQBrEzKEAA_IAF0PcAAOD5QATC4yMGgADwEA-38PAAJWDwEA-----6jxGCIpLGhpZGRlbj1m
YWxzZSxuYW1lPSJvYmplY3RzIixwYW5feD0xNwkA4nk9MjMsdGlsZV9oPTE2CgAQdwoAr3pvb209
MC41fSxqEAtfOGMwMDkEAGEAfAASMAgAHzEEAGQfOYAA-wEXYwwADwQAPR9jgAAFDwQAVQ_AAP8d
F2EkAAUEABI0GAAfMSwAKAQEAAQoAB8xBAABEjQcAFg4ODAwOQQAH2NUAABLODAwYSQAD2AEER85
gAAQDiAADwQAFw5AAA_AAP8ZANQBD_wBAQ_kBAQfY0AAGA6AAA8EAEgPgAD-qS9hNIACKA9AAAgO
gAAPIAAjDwQACh84QAANDyAALwhsAAkEAAMUAA9AAA0PIAAtBQQAGzgEAAMUAA9AAA0PIAARBEQG
DwAHGw_ABjAM1AYPAAcNAPQGDgQADwAF-58OSAQPBAA3H2OAAAUPBABVD4AA-wENYAQPBABYHzhq
EAM-bWFwZhAaUDAuNX19
:: map/test.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0yMiAxOTo1NzozOSIscmV2aXNpb249MjQ5NF1dbHo0AOgBAADRIAAA8EB7e3pvb209MC41LGhp
ZGRlbj1mYWxzZSxuYW1lPSJvYmplY3RzIixwYW5feD0xNyx0aWxlX2g9MTYsYm1wPXVzZXJkYXRh
KCJpMTYiLDMyAwAvIjABAP----83LzMwAQBnEzIEAA8BAP-WD_wBCR8y2AJYHjMsAA_UAD4vMzDs
AA8vMzABAGsTMoQAD4gAXQ9wAA4PlABMLjIwaAAPAQD-fw8AAlYPAQD-----qCIiKScQEHcnEAA6
EG95PTIzfSxqEAo-bWFwZhAfXzhjMDA5BABhAHwAEjAIAB8xBABkHzmAAP8BF2MMAA8EAD0fY4AA
BQ8EAFUPgAD-HRdhJAAFBAASNBgAHzEsACgEBAAEKAAfMQQAARI0HABYODgwMDkEAB9jVAAASzgw
MGEkAA9gBBEfOYAAEA4gAA8EABcOQAAPgAD-GQDUAQ-sAQEPpAQEH2NAABgOgAAPBABID4AA-6kv
YTSAAigPQAAIDoAADyAAIw8EAAofOEAADQ8gAC8IbAAJBAADFAAPQAANDyAALQUEABs4BAADFAAP
QAANDyAAEQREBg8ABxsPgAYwDNQGDwAHDQD0Bg4EAA8ABf_fDkgEDwQANx9jgAAFDwQAVQ_AAP8B
DWAEDwQAWB44ZhBQPTIzfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCJdXQ==
:: pal/
:: pal/0.pal
b64$LS1bW3BvZCxyZXZpc2lvbj0zMSxibGFja2VzdF9jb2xvcj0wLGljb249dXNlcmRhdGEoInU4
IiwxNiwxNiwiMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3
MDcwNzA2MDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDYwNjAxMDAwMDAwMDAwMTA3MDcw
NzA3MDcwNzA3MDcwNjA2MDYwMTAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA2MDYwNjA2MDEwMDAw
MDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzAxMDAwMDAxMDcwNzA2MDYwMTAxMGQwZDAxMDEwNzA3MDEwMDAwMDEwNzA3MDYwNjAxMDEwZDBk
MDEwMTA3MDcwMTAwMDAwMTA3MDcwMTAxMDcwNzA2MDYwZDBkMDcwNzAxMDAwMDAxMDcwNzAxMDEw
NzA3MDYwNjBkMGQwNzA3MDEwMDAwMDEwNzA3MGQwZDAxMDEwZDBkMDYwNjA3MDcwMTAwMDAwMTA3
MDcwZDBkMDEwMTBkMGQwNjA2MDcwNzAxMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEw
MDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDEwMTAxMDAiKSxoaWRkZW5fdG9nZ2xlcz17WzBdPWZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlfSxo
aWRkZW49e1swXT1mYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZX0sbW9k
aWZpZWQ9IjIwMjUtMDEtMjMgMjE6MzI6MzIiLGJnX2NvbG9yPTAsbG9ja2VkPXtbMF09dHJ1ZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVl
LHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0
cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxm
YWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxz
ZSxmYWxzZX0sY3JlYXRlZD0iMjAyNS0wMS0yMyAxOTowNTowMiIsb2twYWxfdmVyc2lvbj0iMS4w
LjMiLHRlc3RfY3ViZV9jb2xvcnM9e1swXT17MTUsMzEsNH0sezMxLDQsMjB9LHs0LDIwLDIxfSx7
MTAsOSwyNX0sezksMjUsMjR9LHs4LDI0LDJ9LHsyNiwxMSwyN30sezExLDI3LDN9LHsyNywzLDE5
fSx7MjgsMTcsMTl9LHsyOCwxMiwxNn0sezEyLDE2LDF9LHs2LDI5LDEzfSx7MjksMTMsMTh9LHsx
MywxOCwxfSx7NywyMywxNH0sezIzLDE0LDEzfSx7MTQsMzAsMTh9LHs3LDYsMjJ9LHs2LDIyLDV9
LHsyMiw1LDIxfSx7MSwxLDF9LHsxLDEsMX0sezEsMSwxfX0sd2hpdGVzdF9jb2xvcj03XV1sejQA
CAEAABUCAAD1BXVzZXJkYXRhKCJpMzIiLDY0LCIwAQD2DzI0MjIyMDAwNWY1NzRmMDBhMjg4Nzkw
MGRiYzNiNRgA4GMyYzNjNzAwZmZmMWU4CABAMDA0ZAgAIGEzSABgZmZlYzI3CgCgZTQzNjAwMjlh
ZCQAYDgzNzY5YyAAMTc3YTgAwGNjYWEwMDFjNWVhYzAA9hVhNWExMDA3NTRlOTcwMDEyNTM1OTAw
NzQyZjI5MDA0OTJkMziYAPAFZmZhY2M1MDBjMzAwNGMwMGViNmJGAFA5MGVjNMkA8AIwYjI1MTAw
NjRkZmY2MDBiZIkAAJYAQDBkYWJAAF84NTZkMAEAbgRYAQ8BAGBQMDAwIik=
:: pal/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTIzIDE5OjA1OjAyIixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCIscmV2aXNpb249MzAxNF1dbHo0AKUAAAAoCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPBwCwANH-8BAP-mUP----9N
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCJdXQ==
:: entity.lua
--[[pod_format="raw",created="2025-01-09 16:01:30",modified="2025-01-14 00:53:59",revision=854]]
--[[pod_format="raw",created="2025-01-06 21:02:01",modified="2025-01-06 21:02:01",revision=0]]
entity = {
    type = 'entity',
}

function entity:new(o)
    local o = o or {}
    setmetatable(o, self)
    self.__index = self
    -- need to set in constructor so it creates a new table object each time
    return o
end

function entity:draw()
    if not self.dead then
        if (self.draw_circle != nil) self:draw_circle()
        if (self.draw_sprite != nil) self:draw_sprite()
        -- local points = self:get_hit_box()
        -- line(points[1][1], points[1][2], points[2][1], points[2][2])
        -- line(points[2][1], points[2][2], points[3][1], points[3][2])
        -- line(points[3][1], points[3][2], points[4][1], points[4][2])
        -- line(points[4][1], points[4][2], points[1][1], points[1][2])
    end
    if (self.draw_particles != nil) self:draw_particles()
    for p in all(self.particles) do
        p:draw()
    end
end

function entity:update(game_state)
	local time_elapsed = game_state.cur_update - game_state.last_update
	if not self.dead then
		if (self.handle_controls != nil) self:handle_controls(game_state)
		if (self.update_duration != nil) self:update_duration(game_state)
		if (self.update_position != nil) self:update_position(game_state)
	end
	if (self.update_particles != nil) self:update_particles(game_state)
end

add_circle = function(self, radius, col)
	self.radius = radius
	self.col = col
	self.draw_circle = function(self)
		circ(self.x, self.y, self.radius, self.col)
	end
	return self
end

add_sprite = function(self, s_id, width, height)
	self.s_id = s_id
	self.width = width
	self.height = height
	self.draw_sprite = function(self)
		spr(self.s_id, self.x-self.width/2, self.y-self.height/2, 1, 1)
	end
	return self
end

add_duration = function(self, duration)
	self.duration = duration
	self.update_duration = function(self, game_state)
		local time_elapsed = game_state.cur_update - game_state.last_update
		if (self.duration < 0) then
			self.dead = true
		else
			self.duration -= time_elapsed
		end
	end
	return self
end

add_particles = function(self)
	self.particles = {}
	self.draw_particles = function(self)
		for p in all(self.particles) do
	        p:draw()
	    end
	end
	self.update_particles = function(self, game_state)
		local time_elapsed = game_state.cur_update - game_state.last_update
		for p in all(self.particles) do
			p:update()
		end
		ArrayRemove(
			self.particles, 
			function(t, i, j)
				if (t[i].dead) return false
				t[i]:update(time_elapsed)
				return true
			end
		)
	end
	return self
end

add_hitbox = function(self, type)
	-- hit box
	self.hb = {
		t = "ngon",
		-- todo, reformat to be ngon
		h = 4,
		w = 4
	}
	self.get_hit_box = function(self)
		return {
			{self.x-self.hb.w, self.y-self.hb.h}, --top left
			{self.x-self.hb.w, self.y+self.hb.h-1}, --bottom left
			{self.x+self.hb.w-1, self.y+self.hb.h-1}, --bottom right
			{self.x+self.hb.w-1, self.y-self.hb.h}, --top right
		}
	end
	self.on_hit = function(self) print("hit") end
	return self
end

add_terrain = function(self)
	self.elevation = 0
	-- top, right, bottom, left cover supplied to surounding spaces
	self.cover = {0, 0, 0, 0}
	self.traversable = true
	return self
end

add_stats = function(self)
	self.owner="player"
	
	-- health
	self.maxHealth = 20
	self.health = 20
	-- armor
	self.maxArmor = 5
	self.armor = 5
	
	-- attributes
	-- controls how fast the unit moves and can get shots off on visible enemies
	self.speed = 5
	-- controls how fast the unit can react. i.e. shooting at enemies peaking from behind cover, moving between cover
	self.reflexes = 5
	-- controls melee damage and how much the unit can carry
	self.strength = 5
	-- controls the health and resistances of the unit
	self.constitution = 5
	-- controls how accurate the unit is with their attacks
	self.accuracy = 5
	return self
end

add_position = function(self)
	self.x = 0
	self.y = 0
	self.move = function(self, new_x, new_y)
		self.x = new_x
		self.y = new_y
	end
	return self
end

-- requires position first
add_movement = function(self, max_velocity, pdx, pdy)
	 -- max velocity
    self.mv = max_velocity or 20
    -- acceleration (pixels per second)
    self.dx = 0
    self.dy = 0
    -- passive decelleration
    self.pdx = pdx or 0
    self.pdy = pdy or 0
    -- velocity
    self.vx = 0
    self.vy = 0
    self.calculate_velocity = function(self, time_elapsed)
    	if (self.dx != 0) then
    		self.vx = mid(-self.mv, self.vx + (self.dx * time_elapsed), self.mv)
    	elseif (self.vx > 0) then
    		self.vx = max(0, self.vx - (self.pdx * time_elapsed))
    	elseif (self.vx < 0) then
    		self.vx = min(0, self.vx + (self.pdx * time_elapsed))
    	end
    	if (self.dy != 0) then
    		self.vy = mid(-self.mv, self.vy + (self.dy * time_elapsed), self.mv)
    	elseif (self.vy > 0) then
    		self.vy = max(0, self.vy - (self.pdy * time_elapsed))
    	elseif (self.vy < 0) then
    		self.vy = min(0, self.vy + (self.pdy * time_elapsed))
    	end
    end
    self.calculate_position = function(self, time_elapsed)
    	self.x += self.vx
    	self.y += self.vy
    end
    self.update_position = function(self, game_state)
    	local time_elapsed = game_state.cur_update - game_state.last_update
		self:calculate_velocity(time_elapsed)
		self:calculate_position(time_elapsed)
    end
    
   return self
end

--https://gamedevacademy.org/lua-inheritance-tutorial-complete-guide/

:: gui.lua
--[[pod_format="raw",created="2025-01-08 17:33:11",modified="2025-01-18 16:37:14",revision=3040]]
wWidth = get_display():width()
wHeight = get_display():height()

gui = create_gui()

function remove_all_children(el)
	for child in all(el.child) do
		el:detach(child)
	end
end

function bgFill(self, col)
	rectfill(0, 0, self.width, self.height, col or 6)
end

function border(self, col)
	rect(0, 0, self.width-1, self.height-1, col or 5)
end

:: hud.lua
--[[pod_format="raw",created="2025-01-14 00:55:33",modified="2025-01-18 16:37:14",revision=1599]]
function create_hud(game_state)
	local hud = gui:attach{
		x=0, y=0, width=wWidth, height=wHeight,
		show_log = nil, show_cpu_usage = nil,
		update=function(self)
			if (game_state.settings.show_log != self.show_log) then
				if (self.log_display != nil) self:detach(self.log_display)
				if (game_state.settings.show_log) then
					self.log_display = self:attach_log_container()
					self.show_log=true
				else
					self.log_display = self:attach_log_button()
					self.show_log=false
				end
			end
			if (game_state.settings.show_cpu_usage != self.show_cpu_usage) then
				if (game_state.settings.show_cpu_usage) then
					self.cpu_display = self:attach_cpu_display()
					self.show_cpu_usage=true
				elseif (self.cpu_display != nil) then
					self:detach(self.cpu_display)
					self.show_cpu_usage=false
				end
			end
		end
	}
	
	hud.attach_log_button = function(self)
		return hud:attach{
			x=self.width-11, y=0,
			width=11, height=11,
			clicked=false,
			draw=function(lb)
				bgFill(lb, lb.clicked and 5 or 6)
				line(2, 2, lb.width-3, 2, 22)
				line(2, 4, lb.width-3, 4, 22)
				line(2, 6, lb.width-3, 6, 22)
				line(2, 8, lb.width-3, 8, 22)
				-- rounded
				pset(0, 0, 0)
				pset(lb.width-1, 0, 0)
				pset(0, lb.height-1, 0)
				pset(lb.width-1, lb.height-1, 0)
			end,
			click=function(lb)
				lb.clicked=true
			end,
			release=function(lb)
				lb.clicked=false
			end,
			tap=function(lb)
				game_state.settings.show_log = true
			end
		}
	end
	
	hud.attach_log_container = function(self)
		local log_container = self:attach{
			x=self.width-200, y=0,
			width=200, height=150,
		}
		
		local title_bar = log_container:attach{
			width=log_container.width, height=11,
			bg_col=22,
			draw=function(tb)
				bgFill(tb, tb.bg_col)
				print("Game Log", 2, 2, 7)
			end
		}
		
		local close_button = title_bar:attach{
			x=title_bar.width-11, y=0, z=50,
			width=11, height=11,
			clicked=false,
			draw=function(cb)
				bgFill(cb, cb.clicked and 5 or 6)
				-- close x
				line(2, 2, cb.width-4, 8, 22)
				line(3, 2, cb.width-3, 8, 22)
				line(2, 8, cb.width-4, 2, 22)
				line(3, 8, cb.width-3, 2, 22)
				-- rounded
				pset(0, 0, title_bar.bg_col)
				pset(cb.width-1, 0, title_bar.bg_col)
				pset(0, cb.height-1, title_bar.bg_col)
				pset(cb.width-1, cb.height-1, title_bar.bg_col)
			end,
			click=function(cb)
				cb.clicked=true
			end,
			release=function(cb)
				cb.clicked=false
			end,
			tap=function(cb)
				game_state.settings.show_log=false
			end
		}
		
		local log_text = log_container:attach_text_editor{
			x=0, y=11, width=log_container.width, height=135,
			has_search=true, show_line_numbers=true,
			text={"test"},--game_state.log,
		}
		
		-- tables passed by reference, so should update automatically
		log_text:set_text(game_state.log)

		local log_text_scrollbar = log_text:attach_scrollbars{}
		
		return log_container
	end
	
	hud.attach_cpu_display = function(self)
		return self:attach {
			x=0, y=0, width=60, height=11,
			draw=function (self)
				bgFill(self, 0)
				print(string.format("CPU: %.3f", stat(1)*100).."%", 2, 2, 7)
			end,
		}
	end
	
	local current_input = hud:attach {
		x=0, y=12, width=50, height=250,
		draw=function(self)
			bgFill(self, 7)
			print(string.format("Input Controls: \n%s", "test"))
		end
	}
	
end

:: loop.lua
--[[pod_format="raw",created="2025-01-09 16:02:14",modified="2025-01-18 16:37:14",revision=2329]]
window{
	pauseable=false
}

screen_width = 480
screen_height = 270

function _init()
    -- enable mouse
    --poke(0x5f2d, 1)
    restart()
end

function _draw()
    cls()
    local update_time = time()

    if (game_state.map_data != nil) then 
        map(game_state.map_data[2].bmp)
    end
    for e in all(game_state.units) do
        e:draw()
    end
    for p in all(game_state.projectiles) do
        p:draw()
    end
    gui:draw_all()
    buttonsPressed = ""
    if (game_state.controls.mouse_b_l) then buttonsPressed = buttonsPressed.."m_b_l, " end
    if (game_state.controls.mouse_b_r) then buttonsPressed = buttonsPressed.."m_b_r, " end
    if (game_state.controls.mouse_b_m) then buttonsPressed = buttonsPressed.."m_b_m, " end
    if (game_state.controls.up) then buttonsPressed = buttonsPressed.."up, " end
    if (game_state.controls.right) then buttonsPressed = buttonsPressed.."right, " end
    if (game_state.controls.down) then buttonsPressed = buttonsPressed.."down, " end
    if (game_state.controls.left) then buttonsPressed = buttonsPressed.."left, " end
    if (game_state.controls.primary) then buttonsPressed = buttonsPressed.."primary, " end
    if (game_state.controls.secondary) then buttonsPressed = buttonsPressed.."secondary, " end
    --print(string.format("cpu: %.3f \ncontrols: %s", stat(1), buttonsPressed), game_state.camera.x, game_state.camera.y, 13)
    --?""
    game_state.last_draw = update_time
end

function _update()
    update(game_state)
end

function restart()
	cls()
	game_state=state:new()

	create_hud(game_state)
end

:: main.lua
--[[pod_format="raw",created="2024-12-30 18:09:39",modified="2025-01-30 22:30:18",revision=2970]]
cd("/appdata/cartridges/tac-tech")
printh(pwd().."/src/pal/main.pal")
poke4(get(fetch(pwd().."/src/pal/main.pal")))
include("src/entity.lua")
include("/appdata/utils/draw.lua")
include("/appdata/utils/dump.lua")
include("/appdata/utils/array.lua")
include("/appdata/utils/vector.lua")
include("/appdata/utils/camera.lua")
include("src/game_map.lua")
include("src/state.lua")
include("src/menus.lua")
include("src/sprites.lua")
include("src/update.lua")
include("src/loop.lua")
include("src/gui.lua")
include("src/menu.lua")
include("src/hud.lua")

:: menu.lua
--[[pod_format="raw",created="2025-01-09 16:03:03",modified="2025-01-18 16:37:14",revision=1929]]
local itemHeight = 14

local function traverse_path(menu_tree, path)
	local val = menu_tree
	for item in all(path) do
		val = val[item]
	end
	return val
end

-- attaches a menu gui object to the specified root element. 


--[[ a map of all the menus. Every instance should have a type of either
	- menu
	- function
	menu must have a list of item names, and an entry that corresponds to each of those
	function must have a call entry, which executes when selected
]]--

function create_menu(tree, path, toggle_check, on_select)
	local path = path or {}
	
	local menu_container = gui:attach{
		x=wWidth/2-50, y=wHeight/2,
		width=100, height=0, -- start at 0 then increase as built.
		hover=1, tree=tree, path=path or {},
		update=function(self)
			local cur_loc = traverse_path(self.tree, self.path)
			if (game_state.controls.down_p) then
				self.hover = self.hover < #cur_loc.items and self.hover+1 or 1
			end
			if (game_state.controls.up_p) then
				self.hover = self.hover > 1 and self.hover-1 or #cur_loc.items
			end
			if (game_state.controls.primary_p) then
				self:select_item(cur_loc.items[self.hover])
			end
		end
	}
	
	menu_container.set_path=function(self, path)
		if (path != self.path) then
			self.path = path
			self:build_menu()
		end
	end
	
	menu_container.select_item=function(self, key)
		local cur_loc = traverse_path(self.tree, self.path)
		local type = cur_loc[key].type
		if (self.on_select != nil) then
			self.on_select(key)
		end
		if (type == "menu") then
			self.path[#self.path+1] = key
			self:build_menu()
		elseif (type == "function") then
			cur_loc[key].call(self)
		elseif (type == "toggle") then
			cur_loc[key].call(self)
		end
	end
	
	function menu_container.build_menu(self)
		remove_all_children(self)
		self.height = 0
		self.y = wHeight/2

		local cur_loc = traverse_path(self.tree, self.path)
		local title = self:attach{
			x=0, y=0,
			width=self.width, height=12,
			draw=function(title)
				print(self.path[#path] or "Main Menu", 2, 2, 1)
			end
		}
		self.y -= title.height/2
		self.height += title.height 	

		for i=1,#cur_loc.items do
			local item = cur_loc[cur_loc.items[i]]
			if (item.type == "toggle") then
				self:attach{
					x=0, y=itemHeight*i,
					width=self.width, height=itemHeight,
					clicked=false,
					draw=function(mi)
						bgFill(mi, mi.clicked and 5 or (self.hover==i and 22) or 7)
						border(mi)
						print(cur_loc.items[i], 3, 3, 1)
						rect(mi.width-11, 2, mi.width-3, mi.height-3, 5)
						if (item.is_checked()) then
							rectfill(mi.width-9, 4, mi.width-5, mi.height-5, 5)
						end
					end,
					click=function(mi) mi.clicked=true end,
					release=function(mi) mi.clicked=false end,
					tap=function(mi)
						self:select_item(cur_loc.items[i])
					end
				}
			else -- menu and func
				self:attach{
					x=0, y=itemHeight*i,
					width=self.width, height=itemHeight,
					clicked=false,
					draw=function(mi)
						bgFill(mi, mi.clicked and 5 or (self.hover==i and 22) or 7)
						border(mi)
						print(cur_loc.items[i], 3, 3, 1)
					end,
					click=function(mi) mi.clicked=true end,
					release=function(mi) mi.clicked=false end,
					tap=function(mi)
						printh("item clicked")
						self:select_item(cur_loc.items[i])
					end
				}
			end
			self.height += itemHeight
			self.y -= itemHeight/2
		end
	end
	
	menu_container:build_menu()
	
	return menu_container
end



:: menus.lua
--[[pod_format="raw",created="2025-01-18 00:47:52",modified="2025-01-18 16:37:14",revision=177]]
pause_menu = {
	type="menu",
	items={"Settings", "Level Select", "Close"},
	["Settings"]={
		type="menu",
		items={
			"Toggle CPU Usage",
			"Back",
		},
		["Toggle CPU Usage"]={
			type="toggle",
			is_checked=function() return game_state.settings.show_cpu_usage end,
			call=function(menu)
				game_state.settings.show_cpu_usage=not game_state.settings.show_cpu_usage
			end,
		},
		["Back"]={
			type="function",
			call=function(menu) menu:set_path({ }) end,
		}
	},
	["Level Select"]={
		type="menu",
		items={"Test", "Back"},
		["Test"]={
			type="function",
			call=function(menu) 
				state:load_map_data("map/test.map")
				gui.detach(menu)
			end,
		},
		["Back"]={
			type="function",
			call=function(menu) menu:set_path({ }) end,
		}
	},
	["Close"]={
		type="function",
		call=function(menu)
			gui:detach(menu)
		end,
	}
}
:: state.lua
--[[pod_format="raw",created="2025-01-13 19:40:16",modified="2025-01-18 16:37:14",revision=1687]]
state = {
	cur_update = nil,
	last_update = time(),
	last_draw = time(),
	camera = cam:new(),
	map_data = nil,
	units = {},
	projectiles = {},
	particles = {},
	-- contains current state of controls being pressed, moved, pos, etc.
	controls = {},
	log = {""},
	settings={
		show_cpu_usage=true,
	},
	pause_menu_open=false,
	log_open=false,
	menus={
	
	},
}

function state:new(o)
	local o = o or {}
	setmetatable(o, self)
	self.__index = self
		
	return o
end

function state:load_map_data(path)
	self:log_msg("loading map data from: "..path)
	self.map_data = fetch(path)
   local ud = self.map_data[1].bmp
   for i=0,(ud:height()-1) do
       for j=0,(ud:width()-1) do
           --printh(dump(ud:get(i,j,1)))
       end
   end
   self.camera:move(0, 0)
end
	-- better to keep these in seperate lists. easier to optimize loops
	-- map = {
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	-- }
	
function state:update_controls()
    local mouse_x, mouse_y, mouse_b, wheel_x, wheel_y = mouse()
    self.controls.last_mouse_pos = self.controls.mouse_pos
    self.controls.mouse_pos = {mouse_x, mouse_y}
    self.controls.mouse_b_l = (mouse_b & 0b0001) == 1
    self.controls.mouse_b_r = (mouse_b & 0b0010) == 2
    self.controls.mouse_b_m = (mouse_b & 0b0100) == 4
    self.controls.mouse_wheel_x = wheel_x
    self.controls.mouse_wheel_y = wheel_y
    self.controls.up = btn(2) or btn(10)
    self.controls.up_p = btnp(2) or btnp(10)
    self.controls.right = btn(1) or btn(9)
    self.controls.right_p = btnp(1) or btnp(9)
    self.controls.down = btn(3) or btn(11)
    self.controls.down_p = btnp(3) or btnp(11)
    self.controls.left = btn(0) or btn(8)
    self.controls.left_p = btnp(0) or btnp(8)
    self.controls.primary = btn(4)
    self.controls.primary_p = btnp(4)
    self.controls.secondary = btn(5)
    self.controls.secondary_p = btnp(5)
    self.controls.pause = btn(6)
    self.controls.pause_p = btnp(6)
end

function state:log_msg(msg)
	table.insert(self.log, msg)
end


:: update.lua
--[[pod_format="raw",created="2025-01-17 23:56:35",modified="2025-01-30 22:30:18",revision=517]]
local function update_pause_menu_state(game_state)
	if (game_state.pause_menu_open and game_state.menus.pause_menu == nil) then
		printh("createing pause menu")
		game_state.menus.pause_menu = create_menu(
			pause_menu,
			{}, 
			function() return game_state.controls.pause_p end, 
			function(key) game_state:log_msg(key.." selected.") end
		)
		game_state.pause_menu_open = true
	elseif (game_state.menus.pause_menu != nil)
		gui:detach(game_state.menus.pause_menu)
		game_state.pause_menu_open = false
	end
end

function update(game_state, prev_state)
	game_state.cur_update = time()

    game_state:update_controls()
    update_pause_menu_state(game_state)
    game_state.camera:update(game_state)
    
    gui:update_all()

    -- loop through all particles, removing them when dead and all child particles are gone
    ArrayRemove(game_state.projectiles, function(t, i, j)
        local v = t[i]
        v:update(game_state)

        return not v.dead or #v.particles > 0
    end)

    -- remove enemies if dead, otherwise update
    ArrayRemove(game_state.units, function(t, i, j)
        local v = t[i]
        if (v.dead) return false
        v:update(game_state)

        return true
    end)

    -- set camera to the camera state location
    camera(game_state.camera.x, game_state.camera.y)

    game_state.last_update = game_state.cur_update
end

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0zMCAyMjozMDoxOCIscnVudGltZT0xMix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5sdWEjMTEiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2Nh
dGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0=
:: [eoc]
