picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MiIscmV2aXNpb249MjA0MV1dbHo0ADoBAACxMgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSw_AP8T9QIP
FSUPFkUG1RYVDqUG9R0OdQ71Ow71BA71BA8VNQ71AlEAHO-wAz8UMD4gDj8VDhAOPQQABnAgPjA_
8AI_KgAGFQAPKQAGHxOFABxT-xQBFA4CABIeCAA1DxUEDAAAFgAiDQQJAAkVAA8KACsDUwAvBA0g
AAEv-gFJAR0f8DEAry--FTIAHn8WEPUA-xXANwAenxLVHgXPFR4FzQMADg9bAB_ftT4FnxUFPgWd
BAAaHx5pAEo-tf4S7wEeDzEA----------------------------------------------------
---------4lQbT04fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MyJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA3IDAzOjQ2OjQ4Iixtb2RpZmllZD0iMjAyNS0w
MS0wNyAwMzo0Njo0OCIscmV2aXNpb249MF1dbHo0AOkBAADRIAAA8Ah7e2JtcD11c2VyZGF0YSgi
aTE2IiwzMgMALyIwAQD-----Ny8zMAEAZxMyBAAPAQD-1g-sAQkfMtgCWB4zLAAPlAA_LzMw7AAP
LzMwAQBrEzKEAA_IAF0PcAAOD5QATC4yMGgADwEA-38PAAJWDwEA-----6jxGCIpLGhpZGRlbj1m
YWxzZSxuYW1lPSJvYmplY3RzIixwYW5feD0xNwkA4nk9MjMsdGlsZV9oPTE2CgAQdwoAr3pvb209
MC41fSxqEAtfOGMwMDkEAGEAfAASMAgAHzEEAGQfOYAA-wEXYwwADwQAPR9jgAAFDwQAVQ_AAP8d
F2EkAAUEABI0GAAfMSwAKAQEAAQoAB8xBAABEjQcAFg4ODAwOQQAH2NUAABLODAwYSQAD2AEER85
gAAQDiAADwQAFw5AAA_AAP8ZANQBD_wBAQ_kBAQfY0AAGA6AAA8EAEgPgAD-qS9hNIACKA9AAAgO
gAAPIAAjDwQACh84QAANDyAALwhsAAkEAAMUAA9AAA0PIAAtBQQAGzgEAAMUAA9AAA0PIAARBEQG
DwAHGw_ABjAM1AYPAAcNAPQGDgQADwAF-58OSAQPBAA3H2OAAAUPBABVD4AA-wENYAQPBABYHzhq
EAM-bWFwZhAaUDAuNX19
:: map/test.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MiIscmV2aXNpb249MTY5Nl1dbHo0AOkBAADRIAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-----Ny8zMAEAZxMyBAAPAQD-1g-sAQkfMtgCWB4zLAAPlAA_LzMw
7AAPLzMwAQBrEzKEAA_IAF0PcAAOD5QATC4yMGgADwEA-38PAAJWDwEA-----6jxGCIpLGhpZGRl
bj1mYWxzZSxuYW1lPSJvYmplY3RzIixwYW5feD0xNwkA4nk9MjMsdGlsZV9oPTE2CgAQdwoAr3pv
b209MC41fSxqEAtfOGMwMDkEAGEAfAASMAgAHzEEAGQfOYAA-wEXYwwADwQAPR9jgAAFDwQAVQ_A
AP8dF2EkAAUEABI0GAAfMSwAKAQEAAQoAB8xBAABEjQcAFg4ODAwOQQAH2NUAABLODAwYSQAD2AE
ER85gAAQDiAADwQAFw5AAA_AAP8ZANQBD_wBAQ_kBAQfY0AAGA6AAA8EAEgPgAD-qS9hNIACKA9A
AAgOgAAPIAAjDwQACh84QAANDyAALwhsAAkEAAMUAA9AAA0PIAAtBQQAGzgEAAMUAA9AAA0PIAAR
BEQGDwAHGw_ABjAM1AYPAAcNAPQGDgQADwAF-58OSAQPBAA3H2OAAAUPBABVD4AA-wENYAQPBABY
HzhqEAM-bWFwZhAaUDAuNX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MyJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjM5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MiIscmV2aXNpb249MjAxNV1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MyJdXQ==
:: entity.lua
--[[pod_format="raw",created="2025-01-09 16:01:30",modified="2025-01-14 00:53:59",revision=854]]
--[[pod_format="raw",created="2025-01-06 21:02:01",modified="2025-01-06 21:02:01",revision=0]]
entity = {
    type = 'entity',
}

function entity:new(o)
    local o = o or {}
    setmetatable(o, self)
    self.__index = self
    -- need to set in constructor so it creates a new table object each time
    return o
end

function entity:draw()
    if not self.dead then
        if (self.draw_circle != nil) self:draw_circle()
        if (self.draw_sprite != nil) self:draw_sprite()
        -- local points = self:get_hit_box()
        -- line(points[1][1], points[1][2], points[2][1], points[2][2])
        -- line(points[2][1], points[2][2], points[3][1], points[3][2])
        -- line(points[3][1], points[3][2], points[4][1], points[4][2])
        -- line(points[4][1], points[4][2], points[1][1], points[1][2])
    end
    if (self.draw_particles != nil) self:draw_particles()
    for p in all(self.particles) do
        p:draw()
    end
end

function entity:update(game_state)
	local time_elapsed = game_state.cur_update - game_state.last_update
	if not self.dead then
		if (self.handle_controls != nil) self:handle_controls(game_state)
		if (self.update_duration != nil) self:update_duration(game_state)
		if (self.update_position != nil) self:update_position(game_state)
	end
	if (self.update_particles != nil) self:update_particles(game_state)
end

add_circle = function(self, radius, col)
	self.radius = radius
	self.col = col
	self.draw_circle = function(self)
		circ(self.x, self.y, self.radius, self.col)
	end
	return self
end

add_sprite = function(self, s_id, width, height)
	self.s_id = s_id
	self.width = width
	self.height = height
	self.draw_sprite = function(self)
		spr(self.s_id, self.x-self.width/2, self.y-self.height/2, 1, 1)
	end
	return self
end

add_duration = function(self, duration)
	self.duration = duration
	self.update_duration = function(self, game_state)
		local time_elapsed = game_state.cur_update - game_state.last_update
		if (self.duration < 0) then
			self.dead = true
		else
			self.duration -= time_elapsed
		end
	end
	return self
end

add_particles = function(self)
	self.particles = {}
	self.draw_particles = function(self)
		for p in all(self.particles) do
	        p:draw()
	    end
	end
	self.update_particles = function(self, game_state)
		local time_elapsed = game_state.cur_update - game_state.last_update
		for p in all(self.particles) do
			p:update()
		end
		ArrayRemove(
			self.particles, 
			function(t, i, j)
				if (t[i].dead) return false
				t[i]:update(time_elapsed)
				return true
			end
		)
	end
	return self
end

add_hitbox = function(self, type)
	-- hit box
	self.hb = {
		t = "ngon",
		-- todo, reformat to be ngon
		h = 4,
		w = 4
	}
	self.get_hit_box = function(self)
		return {
			{self.x-self.hb.w, self.y-self.hb.h}, --top left
			{self.x-self.hb.w, self.y+self.hb.h-1}, --bottom left
			{self.x+self.hb.w-1, self.y+self.hb.h-1}, --bottom right
			{self.x+self.hb.w-1, self.y-self.hb.h}, --top right
		}
	end
	self.on_hit = function(self) print("hit") end
	return self
end

add_terrain = function(self)
	self.elevation = 0
	-- top, right, bottom, left cover supplied to surounding spaces
	self.cover = {0, 0, 0, 0}
	self.traversable = true
	return self
end

add_stats = function(self)
	self.owner="player"
	
	-- health
	self.maxHealth = 20
	self.health = 20
	-- armor
	self.maxArmor = 5
	self.armor = 5
	
	-- attributes
	-- controls how fast the unit moves and can get shots off on visible enemies
	self.speed = 5
	-- controls how fast the unit can react. i.e. shooting at enemies peaking from behind cover, moving between cover
	self.reflexes = 5
	-- controls melee damage and how much the unit can carry
	self.strength = 5
	-- controls the health and resistances of the unit
	self.constitution = 5
	-- controls how accurate the unit is with their attacks
	self.accuracy = 5
	return self
end

add_position = function(self)
	self.x = 0
	self.y = 0
	self.move = function(self, new_x, new_y)
		self.x = new_x
		self.y = new_y
	end
	return self
end

-- requires position first
add_movement = function(self, max_velocity, pdx, pdy)
	 -- max velocity
    self.mv = max_velocity or 20
    -- acceleration (pixels per second)
    self.dx = 0
    self.dy = 0
    -- passive decelleration
    self.pdx = pdx or 0
    self.pdy = pdy or 0
    -- velocity
    self.vx = 0
    self.vy = 0
    self.calculate_velocity = function(self, time_elapsed)
    	if (self.dx != 0) then
    		self.vx = mid(-self.mv, self.vx + (self.dx * time_elapsed), self.mv)
    	elseif (self.vx > 0) then
    		self.vx = max(0, self.vx - (self.pdx * time_elapsed))
    	elseif (self.vx < 0) then
    		self.vx = min(0, self.vx + (self.pdx * time_elapsed))
    	end
    	if (self.dy != 0) then
    		self.vy = mid(-self.mv, self.vy + (self.dy * time_elapsed), self.mv)
    	elseif (self.vy > 0) then
    		self.vy = max(0, self.vy - (self.pdy * time_elapsed))
    	elseif (self.vy < 0) then
    		self.vy = min(0, self.vy + (self.pdy * time_elapsed))
    	end
    end
    self.calculate_position = function(self, time_elapsed)
    	self.x += self.vx
    	self.y += self.vy
    end
    self.update_position = function(self, game_state)
    	local time_elapsed = game_state.cur_update - game_state.last_update
		self:calculate_velocity(time_elapsed)
		self:calculate_position(time_elapsed)
    end
    
   return self
end

--https://gamedevacademy.org/lua-inheritance-tutorial-complete-guide/

:: gui.lua
--[[pod_format="raw",created="2025-01-08 17:33:11",modified="2025-01-15 01:48:42",revision=2262]]
wWidth = get_display():width()
wHeight = get_display():height()

gui = create_gui()

function remove_all_children(el)
	for child in all(el.child) do
		el:detach(child)
	end
end

function bgFill(self, col)
	rectfill(0, 0, self.width, self.height, col or 6)
end

function border(self, col)
	rect(0, 0, self.width-1, self.height-1, col or 5)
end

:: hud.lua
--[[pod_format="raw",created="2025-01-14 00:55:33",modified="2025-01-15 01:48:42",revision=772]]
function create_hud(game_state)

	local hud = gui:attach({
		x=0, y=0, width=wWidth, height=wHeight,
		attach_log_button=function(self)
		end
	})
	
	local log_container = hud:attach{
		x=wWidth-200, y=0,
		width=200, height=150,
		attach_log_button = function(self)
			remove_all_children(self)
			self:attach{
				x=self.width-11, y=0,
				width=11, height=11,
				clicked=false,
				draw=function(self)
					bgFill(self, self.clicked and 5 or 6)
					line(2, 2, self.width-3, 2, 22)
					line(2, 4, self.width-3, 4, 22)
					line(2, 6, self.width-3, 6, 22)
					line(2, 8, self.width-3, 8, 22)
					-- rounded
					pset(0, 0, 0)
					pset(self.width-1, 0, 0)
					pset(0, self.height-1, 0)
					pset(self.width-1, self.height-1, 0)
				end,
				click=function(self)
					self.clicked=true
				end,
				release=function(self)
					self.clicked=false
				end,
				tap=function(self)
					remove_all_children(log_container)
					log_container:attach_log()
				end
			}
		end,
		attach_log = function(self)
			remove_all_children(self)
			local title_bar = log_container:attach{
				width=log_container.width, height=11,
				bg_col=22,
				draw=function(self)
					bgFill(self, self.bg_col)
					print("Game Log", 2, 2, 7)
				end
			}
			
			local close_button = title_bar:attach{
				x=title_bar.width-11, y=0, z=50,
				width=11, height=11,
				clicked=false,
				draw=function(self)
					bgFill(self, self.clicked and 5 or 6)
					-- close x
					line(2, 2, self.width-4, 8, 22)
					line(3, 2, self.width-3, 8, 22)
					line(2, 8, self.width-4, 2, 22)
					line(3, 8, self.width-3, 2, 22)
					-- rounded
					pset(0, 0, title_bar.bg_col)
					pset(self.width-1, 0, title_bar.bg_col)
					pset(0, self.height-1, title_bar.bg_col)
					pset(self.width-1, self.height-1, title_bar.bg_col)
				end,
				click=function(self)
					self.clicked=true
				end,
				release=function(self)
					self.clicked=false
				end,
				tap=function(self)
					remove_all_children(log_container)
					log_container:attach_log_button()
				end
			}
			
			local log_text = log_container:attach_text_editor{
				x=0, y=11, width=log_container.width, height=135,
				has_search=true, show_line_numbers=true,
				text={"test"},--game_state.log,
			}
			
			-- tables passed by reference, so should update automatically
			log_text:set_text(game_state.log)
	
			local log_text_scrollbar = log_text:attach_scrollbars{}
		end
	}
	
	log_container:attach_log_button()
	
	local cpu_usage_container = hud:attach {
		x=0, y=0, width=55, height=11,
		visible=game_state.settings.show_cpu_usage,
		draw=function (self)
			bgFill(self, 0)
			print(string.format("CPU: %.3f", stat(1)*100).."%", 2, 2, 7)
		end
	}
	
	local current_input = hud:attach {
		x=0, y=12, width=50, height=250,
		draw=function(self)
			bgFill(self, 7)
			print(string.format("Input Controls: \n%s", "test"))
		end
	}
	
end

:: loop.lua
--[[pod_format="raw",created="2025-01-09 16:02:14",modified="2025-01-15 01:48:42",revision=1569]]
window{
	pauseable=false
}

screen_width = 480
screen_height = 270

function _init()
    -- enable mouse
    --poke(0x5f2d, 1)
    restart()
end

function _draw()
    cls()
    local update_time = time()

    if (game_state.map_data != nil) then 
        map(game_state.map_data[2].bmp)
    end
    for e in all(game_state.units) do
        e:draw()
    end
    for p in all(game_state.projectiles) do
        p:draw()
    end
    gui:draw_all()
    buttonsPressed = ""
    if (game_state.controls.mouse_b_l) then buttonsPressed = buttonsPressed.."m_b_l, " end
    if (game_state.controls.mouse_b_r) then buttonsPressed = buttonsPressed.."m_b_r, " end
    if (game_state.controls.mouse_b_m) then buttonsPressed = buttonsPressed.."m_b_m, " end
    if (game_state.controls.up) then buttonsPressed = buttonsPressed.."up, " end
    if (game_state.controls.right) then buttonsPressed = buttonsPressed.."right, " end
    if (game_state.controls.down) then buttonsPressed = buttonsPressed.."down, " end
    if (game_state.controls.left) then buttonsPressed = buttonsPressed.."left, " end
    if (game_state.controls.primary) then buttonsPressed = buttonsPressed.."primary, " end
    if (game_state.controls.secondary) then buttonsPressed = buttonsPressed.."secondary, " end
    --print(string.format("cpu: %.3f \ncontrols: %s", stat(1), buttonsPressed), game_state.camera.x, game_state.camera.y, 13)
    --?""
    game_state.last_draw = update_time
end

function _update()
    game_state.cur_update = time()

    game_state:update_controls()
    game_state.camera:update(game_state)
    
    gui:update_all()

    -- loop through all particles, removing them when dead and all child particles are gone
    ArrayRemove(game_state.projectiles, function(t, i, j)
        local v = t[i]
        v:update(game_state)

        return not v.dead or #v.particles > 0
    end)

    -- remove enemies if dead, otherwise update
    ArrayRemove(game_state.units, function(t, i, j)
        local v = t[i]
        if (v.dead) return false
        v:update(game_state)

        return true
    end)

    -- set camera to the camera state location
    camera(game_state.camera.x, game_state.camera.y)

    game_state.last_update = game_state.cur_update
end

function restart()
    cls()
    game_state=state:new()
    create_hud(game_state)
end

:: main.lua
--[[pod_format="raw",created="2024-12-30 18:09:39",modified="2025-01-15 01:48:42",revision=1954]]
include("entity.lua")
include("/appdata/utils/dump.lua")
include("/appdata/utils/array.lua")
include("/appdata/utils/camera.lua")
include("state.lua")
include("loop.lua")
include("gui.lua")
include("menu.lua")
include("hud.lua")

:: menu.lua
--[[pod_format="raw",created="2025-01-09 16:03:03",modified="2025-01-15 01:48:42",revision=1049]]
local itemHeight = 14

local function traverse_path(menu_tree, path)
	local val = menu_tree
	for item in all(path) do
		val = val[item]
	end
	return val
end

-- attaches a menu gui object to the specified root element. 
local function attach_menu(root_el, menu_tree, path)
	local path = path or {}

	remove_all_children(root_el)
	local menu = traverse_path(menu_tree, path)
	
	local select_item = function(key)
		printh(key.." selected")
		local type = menu[key].type
		if (type == "menu") then
			path[#path+1] = key
			attach_menu(root_el, menu_tree, path)
		elseif (type == "function") then
			menu[key].call(root_el, menu_tree)
		elseif (type == "toggle") then
			menu[key].call(not menu[key].checked, root_el, menu_tree)
		end
	end
	
	local menu_container = root_el:attach{
		x=wWidth/2-50, y=wHeight/2-(#menu.items+1)*itemHeight,
		width=100, height=(#menu.items+1)*itemHeight,
		hover=1,
		draw=function(self)
			bgFill(self)
		end,
		update=function(self)
			if (game_state.controls.down_p) then
				self.hover = self.hover < #menu.items and self.hover+1 or 1
			end
			if (game_state.controls.up_p) then
				self.hover = self.hover > 1 and self.hover-1 or #menu.items
			end
			if (game_state.controls.primary_p) then
				select_item(menu.items[self.hover])
			end
		end
	}

	local title = menu_container:attach{
		x=0, y=0,
		width=menu_container.width, height=12,
		draw=function(self)
			print("Main Menu", 2, 2, 1)
		end
	}
	
	for i=1,#menu.items do
		local item = menu[menu.items[i]]
		if (item.type == "toggle") then
			menu_container:attach{
				x=0, y=itemHeight*i,
				width=menu_container.width, height=itemHeight,
				clicked=false,
				draw=function(self)
					bgFill(self, self.clicked and 5 or menu_container.hover==i and 22 or 7)
					border(self)
					print(menu.items[i], 3, 3, 1)
					rect(self.width-11, 2, self.width-3, self.height-3, 5)
					if (item.checked) then
						rectfill(self.width-9, 4, self.width-5, self.height-5, 5)
					end
				end,
				click=function(self) self.clicked=true end,
				release=function(self) self.clicked=false end,
				tap=function(self) 
					select_item(menu.items[i])
				end
			}
		else -- menu and func
			menu_container:attach{
				x=0, y=itemHeight*i,
				width=menu_container.width, height=itemHeight,
				clicked=false,
				draw=function(self)
					bgFill(self, self.clicked and 5 or menu_container.hover==i and 22 or 7)
					border(self)
					print(menu.items[i], 3, 3, 1)
				end,
				click=function(self) self.clicked=true end,
				release=function(self) self.clicked=false end,
				tap=function(self) 
					select_item(menu.items[i])
				end
			}
		end
	end
end

--[[ a map of all the menus. Every instance should have a type of either
	- menu
	- function
	menu must have a list of item names, and an entry that corresponds to each of those
	function must have a call entry, which executes when selected
]]--

local main_menu = gui:attach({
	x=0, y=0, width=wWidth, height=wHeight,
	paused=false,
	toggle=function(self)
		if (self.paused) then
			self.paused = false
			remove_all_children(self)
		else
			self.paused=true
			attach_menu(self, game_state.menus.main_menu_tree, {})
		end
	end,
	update=function (self)
		if (game_state.controls.pause_p) then 
			self:toggle()
		end
	end
})

:: state.lua
--[[pod_format="raw",created="2025-01-13 19:40:16",modified="2025-01-15 01:48:42",revision=907]]
state = {
	cur_update = nil,
	last_update = time(),
	last_draw = time(),
	camera = cam:new(),
	map_data = nil,
	units = {},
	projectiles = {},
	particles = {},
	-- contains current state of controls being pressed, moved, pos, etc.
	controls = {},
	log = {""},
	settings={
		show_cpu_usage=true
	},
	menus={
	
	},
}

function state:new(o)
	local o = o or {}
	setmetatable(o, self)
	self.__index = self
	
	self.menus.main_menu_tree={
		type="menu",
		items={"Settings", "Level Select", "Close"},
		["Settings"]={
			type="menu",
			items={
				"Toggle CPU Usage",
			},
			["Toggle CPU Usage"]={
				type="toggle",
				checked=self.settings.show_cpu_usage,
				call=function(checked, menu, menu_tree)
					printh("setting show cpu usage: "..(checked and "true" or "false"))
					self.settings.show_cpu_usage=checked
				end,
			},
		},
		["Level Select"]={
			type="menu",
			items={"Test", "Back"},
			["Test"]={
				type="function",
				call=function(menu, menu_tree) 
					self:load_map_data("map/test.map")
					menu:toggle()
				end,
			},
			["Back"]={
				type="function",
				call=function(menu, menu_tree) attach_menu(menu, menu_tree, { }) end,
			}
		},
		["Close"]={
			type="function",
			call=function(menu, menu_tree)
				menu:toggle()
			end,
		}
	}
		
	return o
end

function state:load_map_data(path)
	self:log_msg("loading map data from: "..path)
	self.map_data = fetch(path)
   local ud = self.map_data[1].bmp
   for i=0,(ud:height()-1) do
       for j=0,(ud:width()-1) do
           --printh(dump(ud:get(i,j,1)))
       end
   end
   self.camera:move(0, 0)
end
	-- better to keep these in seperate lists. easier to optimize loops
	-- map = {
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     { terrain:new() }, { terrain:new() }, { terrain:new() }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), }, { terrain:new(), },
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	--     nil, nil, { terrain:new() }, { terrain:new(), }, {terrain:new(), }, nil, nil,
	-- }
	
function state:update_controls()
    local mouse_x, mouse_y, mouse_b, wheel_x, wheel_y = mouse()
    self.controls.last_mouse_pos = self.controls.mouse_pos
    self.controls.mouse_pos = {mouse_x, mouse_y}
    self.controls.mouse_b_l = (mouse_b & 0b0001) == 1
    self.controls.mouse_b_r = (mouse_b & 0b0010) == 2
    self.controls.mouse_b_m = (mouse_b & 0b0100) == 4
    self.controls.mouse_wheel_x = wheel_x
    self.controls.mouse_wheel_y = wheel_y
    self.controls.up = btn(2) or btn(10)
    self.controls.up_p = btnp(2) or btnp(10)
    self.controls.right = btn(1) or btn(9)
    self.controls.right_p = btnp(1) or btnp(9)
    self.controls.down = btn(3) or btn(11)
    self.controls.down_p = btnp(3) or btnp(11)
    self.controls.left = btn(0) or btn(8)
    self.controls.left_p = btnp(0) or btnp(8)
    self.controls.primary = btn(4)
    self.controls.primary_p = btnp(4)
    self.controls.secondary = btn(5)
    self.controls.secondary_p = btnp(5)
    self.controls.pause = btn(6)
    self.controls.pause_p = btnp(6)
end

function state:log_msg(msg)
	table.insert(self.log, msg)
end


:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTMwIDE4OjA5OjU5Iixtb2RpZmllZD0iMjAyNS0w
MS0xNSAwMTo0ODo0MyIscnVudGltZT0xMix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Imd1aS5sdWEj
MTQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Im1lbnUubHVhIzExMCIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iaHVkLmx1YSM5OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2Nh
dGlvbj0ic3RhdGUubHVhIzM4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJsb29wLmx1
YSM3NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibWFpbi5sdWEjMSIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvdGVzdC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNm
eCIsd29ya3NwYWNlX2luZGV4PTR9fV1d
:: [eoc]
